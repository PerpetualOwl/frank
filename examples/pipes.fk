{--- Pipes: multihandlers ---}

include prelude

interface Send X = send : X -> Unit
interface Receive X = receive : X

-- send a list of values
sends : {List X -> [Send X]Unit}
sends xs = map send xs; unit

-- receive and concatenate a nil-terminated list of lists
catter : {[Receive (List X)]List X}
catter! = case receive! { []  -> []
                        | xs  -> append xs catter!}

pipe : {<Send X>Unit -> <Receive X>Y -> [Abort]Y}
pipe <send x -> s> <receive -> r> = pipe (s unit) (r x)
pipe      <_>           y              = y
pipe     unit      <receive -> r> = abort!

doBeDoBeDoNil : {List String}
doBeDoBeDoNil! = ["do", "be", "do", "be", "do", ""]

sendDoBeDoBeDoNil : {[Send String]Unit}
sendDoBeDoBeDoNil! = sends doBeDoBeDoNil!

t1 : {[Abort]String}
t1! = pipe sendDoBeDoBeDoNil! catter!

spacer : [Send String, Receive String]Unit
spacer! = send receive!; send " "; spacer!

t2 : {[Abort]String}
t2! = pipe sendDoBeDoBeDoNil! (pipe spacer! catter!)

catchList : {<Abort>List X -> List X}
catchList <x> = catch x! {[]}

t3 : {String}
t3! = catchList t2!

t4 : {String}
t4! = catchList (pipe (sends ["do", "be", []])
                      (pipe spacer! catter!))

sendsPrint : {List String -> [Console, Send String]Unit}
sendsPrint []        = unit
sendsPrint (s :: ss) = print "Sending: "; print s; ouch '\n'; send s; sendsPrint ss

t5 : {[Console]String}
t5! = catchList (pipe (sendsPrint doBeDoBeDoNil!) catter!)

logSend : {<Send String>X -> [Console, Send String]X}
logSend x             = x
logSend <send s -> k> = print "Sending: "; print s; ouch '\n'; send s; logSend (k unit)

t6 : {[Console]String}
t6! = catchList (pipe (logSend sendDoBeDoBeDoNil!) catter!)

lift1Send : {{[E|Send Y]X} -> {[E|Send Y,Send Y]X}}
lift1Send m = {(lift <Send> (lift <Send> (lift1Send' m!)))!}

lift1Send' : <Send Y>X -> [E|]{[E|Send Y,Send Y]X}
lift1Send'  x           = {x}
lift1Send' <send y -> k> = {case (send y) {x -> (lift1Send {k x})!}}

lift1Recv : {{[E|Receive Y]X} -> {[E|Receive Y,Receive Y]X}}
lift1Recv m = {(lift <Receive> (lift <Receive> (lift1Recv' m!)))!}

lift1Recv' : <Receive Y>X -> [E|]{[E|Receive Y,Receive Y]X}
lift1Recv'  x           = {x}
lift1Recv' <receive -> k> = {case receive! {x -> (lift1Recv {k x})!}}

-- lift Abort's in this defn. are needed because we demand equality for the
-- abilities of a called operator and the ambient. Soln: implement subtyping
-- relation for abilities.
--
-- On the other hand, we may allow the children a, b and c to perform abort's.
-- Would the equivalence between tM and tN still hold in this case?
-- I think Abort *needs* to be within the children's abilities because that is
-- the semantics of pipe: APP adds Abort to all the adjustments when invoked.
tM : {{[Abort,Send X]Unit} ->
      {[Abort,Send X,Receive X]Unit} ->
      {[Abort,Receive X]Y} ->
      [Abort]Y}
tM a b c = pipe a! (pipe b! (lift1Recv c)!)

tN : {{[Abort,Send X]Unit} ->
      {[Abort,Send X,Receive X]Unit} ->
      {[Abort,Receive X]Y} ->
      [Abort]Y}
tN a b c = pipe (pipe (lift1Send a)! b!) c!

t7 : {[Abort]String}
t7! = tM sendDoBeDoBeDoNil spacer catter

t8 : {[Abort]String}
t8! = tN sendDoBeDoBeDoNil spacer catter

-- Dont delete these lines, they make this program into a unit test.
-- #desc   examples/pipes.fk
-- #flags  ~include examples/
-- #return unit
main: {Unit}
main! = unit
